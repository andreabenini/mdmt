#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# MDMT  -   MarkDown Multi Tool
#           Convert MD files to something else for easy rendering or printing
# @author   Ben <Andrea Benini>.  Email on github website for details
# @see      https://github.com/andreabenini/mdmt
# @version  v0.9.2
# @license  GPLv3
#
# @see      See URL for details, documentation, issues, changelog
#
# pyright: reportMissingImports=false
import re
import os
import sys
import base64
import shutil
import optparse
import markdown
import requests

fileFormats = ['md', 'htm', 'html', 'pdf']
pageFormats = ['A4', 'Letter']

class _mdmtBase:
    def __init__(self, name=None, utility=None, verbose=False):
        self._name   = name
        self.__verbose = verbose
        if utility:
            self._utility = os.popen(f"which {utility} 2>/dev/null").read().strip()
            self.__valid   = False if not self._utility else True
            if not self.isValid:
                print(f"ERROR: Command line utility '{utility}' not found", file=sys.stderr)
        else:
            self.__valid = True
    def read(self, fileName=None):
        with open(fileName) as f:
            return f.read()
    def write(self, fileName=None, contents=''):
        try:
            with open(fileName, 'w') as f:
                f.write(contents)
            return True
        except Exception:
            return False
    @property
    def isValid(self):
        return self.__valid
    @property
    def verbose(self):
        return self.__verbose

class mdmtMD(_mdmtBase):
    def __init__(self, name=None, verbose=False):
        super().__init__(name=name, utility=None, verbose=verbose)

    # Convert Mermaid graphs to scalable vector graphics for easy rendering
    def mermaid2SVG(self, matchObj):
        if matchObj and matchObj.group(2):  # .group(2)=MermaidGraph
            if self.verbose:
                print('- Mermaid block code found. Using online service for static rendering')
            mermaidGraph = matchObj.group(2)
            matchEncoded = mermaidGraph.encode("ascii")
            base64Bytes  = base64.b64encode(matchEncoded)
            base64String = base64Bytes.decode("ascii")    # Here is
            request = requests.get('https://mermaid.ink/svg/'+base64String)
            if request.status_code in range(200, 299):
                return str(request.content, encoding='UTF-8')+"\n"
        if self.verbose:
            print('- Mermaid block code found. Malformed markdown block (regexp error)')
        return "[[ E R R O R ]]"

    # Markdown preprocessor method
    def __preprocessor(self, fileName=None):
        streamBuffer = super().read(fileName=fileName)
        # Mermaid preprocessor, convert diagrams into SVG before rendering
        regex = r"(?s)(?P<MermaidHeader>^```mermaid$\n)(?P<MermaidGraph>.*?)(?P<MermaidFooteer>^```$\n?)"
        streamBuffer = re.sub(regex, self.mermaid2SVG, streamBuffer, 0, re.MULTILINE)
        #
        return streamBuffer

    def read(self, fileName=None, template=None):
        try:
            page = markdown.markdown(
                    self.__preprocessor(fileName=fileName),     # Contents
                    tab_length=2,                               # Options
                    extensions=['admonition', 'extra', 'legacy_attrs', 'legacy_em', 'meta', 'sane_lists', 'smarty', 'toc', 'tables', 'wikilinks']  # Plugins
                                # 'nl2br'       text-align: justify is more pleasant on rendering
                                # 'codehilite' avoided, might cause errors on CSS rendering
            )
            if self.readRaw(fileName=template):
                cssTemplate = f"<link rel='stylesheet' href='{template}'>"     # Workaround for wkhtmltopdf bug on relative paths
            else:
                print(f"WARNING: Template file '{template}' not found, ignoring CSS formatting")
                cssTemplate = ''
            return f"""<!DOCTYPE html>
<html>
<head>
    <title>{self._name}</title>
    <meta charset="UTF-8">
    <meta name="generator" content="mdmt">
    {cssTemplate}
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="https://twemoji.maxcdn.com/2/twemoji.min.js?11.2"></script>        <!-- Rendering UTF-8 emoji -->
    <script>window.onload=function() {{ twemoji.parse(document.body); }}</script>     <!-- Emoji rendering -->
</head>
<body class="markdown-body">
{page}
</body>
</html>
"""
        except Exception:
            print(f"ERROR: Cannot open '{fileName}'", file=sys.stderr)
            return None
    def readRaw(self, fileName=None):
        try:
            return super().read(fileName=fileName)
        except:
            return None

class mdmtHTML(_mdmtBase):
    def __init__(self, verbose=False):
        super().__init__(verbose=verbose)
    def write(self, fileName=None, contents=''):
        if not super().write(fileName=fileName, contents=contents):
                print(f"ERROR: Cannot write '{fileName}", file=sys.stderr)

class mdmtPDF(_mdmtBase):
    def __init__(self, name='', verbose=False):
        super().__init__(name=name, utility='wkhtmltopdf', verbose=verbose)
    def write(self, fileName=None, contents='', page=None):
        try:
            tmpFile = fileName+'.tmp.html'        # Dirty hack for local file access bug
            if super().write(fileName=tmpFile, contents=contents):
                os.popen(f"{self._utility} --log-level error --enable-local-file-access --page-size '{page}' --encoding 'UTF-8' '--title' '{self._name}' '{tmpFile}' '{fileName}'").read().encode()
                os.unlink(tmpFile)
        except Exception as E:
            print(f"ERROR: Cannot write {fileName}", file=sys.stderr)
            print(str(E))

class mdmt:
    # Constructors
    def __init__(self, inputFile=None, outputFile=None, template=None, pageSize=None, header=None, verbose=False):
        # Input/Output files checking
        self.__verbose = verbose
        self.__valid = False
        if not inputFile or not outputFile:
            print("ERROR: Invalid input/output files", file=sys.stderr)
            return
        self.__input  = inputFile
        (self.__inputName, self.__inputExt) = os.path.splitext(os.path.basename(self.__input))
        self.__inputExt = self.__inputExt[1:]
        self.__output = outputFile
        # PageSize
        self.__pageSize = pageSize.capitalize()
        if self.__pageSize not in pageFormats:
            print("ERROR: Invalid page size, allowed values: "+','.join(pageFormats), file=sys.stderr)
            return
        #
        self.__header = header              # (int) or (None)
        self.__valid = True
        self.__template = template

    def convert(self, fileFormat=None):
        self.__convertCheck(fileFormat=fileFormat)
        if not self.isValid:
            return 1
        # Reading input file (to [streamBuffer])
        fileInput = mdmtMD(name=self.__inputName, verbose=self.__verbose)
        if not fileInput.isValid:
            return 1
        if self.__inputExt == 'md':     # markdown
            streamBuffer = fileInput.read(fileName=self.__input, template=self.__template)
        else:                           # .html .htm
            streamBuffer = fileInput.readRaw(fileName=self.__input)
        if not streamBuffer:
            return 1
        # Writing output file, based on file type
        if self.__outputExt == 'md':
            shutil.copyfile(self.__inputName, self.__output)
        elif self.__outputExt == 'html' or self.__outputExt == 'htm':
            fileOutput = mdmtHTML(verbose=self.__verbose)
            fileOutput.write(fileName=self.__output, contents=streamBuffer)
        elif self.__outputExt == 'pdf':
            fileOutput = mdmtPDF(name=self.__inputName, verbose=self.__verbose)
            fileOutput.write(fileName=self.__output, contents=streamBuffer, page=self.__pageSize)
        else:
            print(f"ERROR: Extension '{self.__outputExt}' not supported", file=sys.stderr)
            return 1
        print(f"Generated file: '{self.__output}'")
        return 0

    # Detecting input and output file formats
    def __convertCheck(self, fileFormat=None):
        # Detecting output file format
        if not fileFormat:  # Take it from output file if not specified
            (_, self.__outputExt) = os.path.splitext(self.__output)
            self.__outputExt = self.__outputExt[1:]
        else:
            self.__outputExt = fileFormat
        if self.__outputExt not in fileFormats:
            print("ERROR: Invalid output format", file=sys.stderr)
            self.__valid = False
            return
        # Detecting input file format
        allowedInputExts = fileFormats.copy()
        allowedInputExts.pop()
        if self.__inputExt not in allowedInputExts:
            print("ERROR: Invalid input format", file=sys.stderr)
            self.__valid = False
            return
        # html->md conversion is in the todo list
        if self.__inputExt in ['html', 'htm'] and self.__outputExt=='md':
            print("ERROR: Conversion HTML->MD not yet supported", file=sys.stderr)
            self.__valid = False

    # Write contents to __currentFile. Used by [self.__splitHeaders*() functions]
    def __write(self, contents=''):
        try:
            with open(self.__currentFile, 'a+') as f:
                f.write(contents)
            return True
        except Exception:
            return False

    # Get unique dir or file name for newly created [__currentFile]
    def __splitHeadersAddPath(self, dir=None, file=None):
        path = os.path.sep.join(self.__dirWalk) + os.path.sep
        if dir:
            while os.path.isdir(path+dir):
                dir += '_'
            os.mkdir(path+dir)
            path = path + dir + os.path.sep
            self.__dirWalk += [dir]
        else:
            while os.path.isfile(path+file):
                filename, extension = os.path.splitext(file)
                file = filename + '_' + extension
        self.__currentFile = path + file

    # Split markdown input stream into multiple files by using [self.__header]
    def splitHeaders(self):
        # Input params checks
        self.__splitHeadersCheckInput()
        if not self.isValid:
            return 1
        # Reading input stream
        try:
            fInput = open(self.__input, 'r')
            inputLines = fInput.readlines()
            self.__dirWalk = [self.__output]
            self.__ignoreParsing = False
            self.__splitHeadersAddPath(file='README.md')
            for line in inputLines:
                self.__splitHeadersDetectHeader(line)
                self.__write(contents=line)
            return 0
        except Exception as E:
            print(f"ERROR: {E}", file=sys.stderr)
            return 1
    # Detect input parameters, used once into [__splitHeadersCheckInput] method only
    def __splitHeadersCheckInput(self):
        try:
            # Header parameter check
            if not self.__header:
                raise TypeError('Header parameter required')
            self.__header = int(self.__header)
            if self.__header <= 0:
                raise TypeError('Header must be a positive number')
            # output destination directory check
            if not os.path.isdir(self.__output):
                self.__output = os.path.dirname(self.__output)
                if not os.path.isdir(self.__output):
                    raise TypeError(f"'{self.__output}' isn't a valid output directory")
            return
        except TypeError as E:
            print(f"ERROR: {E}", file=sys.stderr)
        except ValueError:
            print(f"ERROR: Header must be a positive number ({self.__header})", file=sys.stderr)
        self.__valid = False
    # Detect if current line has a valid header in it, used once into [__splitHeadersCheckInput] only
    def __splitHeadersDetectHeader(self, line):
        currentLine = line.strip()
        if currentLine == '':
            return
        elif currentLine.startswith('```'):
            self.__ignoreParsing = not self.__ignoreParsing
            return
        if not self.__ignoreParsing:
            (Level, Title) = self.__splitHeadersGetHeader(currentLine)
            if Level:
                if Level == self.__header:
                    self.__splitHeadersAddPath(file=Title+'.md')
                else:
                    while len(self.__dirWalk) > Level:
                        self.__dirWalk.pop()
                    self.__splitHeadersAddPath(dir=Title, file='README.md')

    # Get [H] title from input stream [currentLine]
    # @return (level, title) Current header level detected (<= self.__header)
    #           Level: None or current header level
    #           Title: None or properly formated title for file or dir creation (strip special chars)
    def __splitHeadersGetHeader(self, currentLine):
        firstWord = currentLine.split()[0]
        if len(firstWord)>0 and firstWord=='#'*len(firstWord):   # Got an header
            Level = len(firstWord) if len(firstWord)<=self.__header else None
            Title = currentLine[currentLine.find(firstWord)+len(firstWord):].strip()
            Title = re.sub('[^a-zA-Z0-9_\-\. ]', '', Title)
            return (Level, Title)
        else:
            return (None, None)


    @classmethod
    def inputFromStdin(cls, outputFileLocation=None):
        try:
            tmpInputFile = f"{outputFileLocation}.tmp.md"
            fOutput = open(tmpInputFile, "w+")
            for inputFile in sys.stdin:
                fInput = open(inputFile.strip(), "r")
                fOutput.write(fInput.read())
                fInput.close()
            fOutput.close()
            return tmpInputFile
        except Exception:
            print("ERROR: Cannot concatenate multiple files", file=sys.stderr)
            return None

    # Properties
    @property
    def isValid(self):
        return self.__valid


## - - - -  MAIN  - - - -  ##
if __name__ == '__main__':
    # Input parameters
    parser = optparse.OptionParser(usage=f"%prog [options]\n       Markdown Management Tool utility\n       Convert markdown files to your favorite format")
    # parser = optparse.OptionParser()
    parser.add_option('-v', '--verbose',      dest='verbose',    default=False,      help='Verbose output information', action='store_true')
    parser.add_option('-i', '--input',        dest='inputFile',  default='',         help='Input file to convert (*.md)')
    parser.add_option('-l', '--input-list',   dest='inputList',  default=None,       help='Concat *.MD list from stdin as one sigle file')
    parser.add_option('-o', '--output',       dest='outputFile', default='',         help=f"Destination file name ({','.join(fileFormats)})")
    parser.add_option('-t', '--type',         dest='outputType', default=None,       help=f"Force output to one of these values: ({','.join(fileFormats)}) autodetected by default")
    parser.add_option('-p', '--page',         dest='page',       default='A4',       help=f"Page size (when applicable) ({','.join(pageFormats)})")     # A4: Default
    parser.add_option('-H', '--header-split', dest='header',     default=None,       help=f"Split a markdown by headers")
    parser.add_option('-T', '--template',     dest='template',   default='mdmt.css', help=f"CSS template to apply, default: mdmt.css")
    (options, _) = parser.parse_args()
    if (not options.inputFile and not options.inputList) or not options.outputFile:
        parser.print_help()
        sys.exit(1)
    if options.inputList == '-':
        inputFile = mdmt.inputFromStdin(outputFileLocation=options.outputFile)
        if not inputFile:
            sys.exit(1)
    else:
        inputFile = options.inputFile
    # Object init
    returnCode = 1
    if not os.path.isabs(options.template):     # Calculate abs path for template file class
        templateFile = os.path.abspath(os.getcwd()) + os.path.sep + options.template
    converter = mdmt(verbose=options.verbose, inputFile=inputFile, outputFile=options.outputFile, template=templateFile, pageSize=options.page, header=options.header)
    if options.header:                          # Split file by headers
        returnCode = converter.splitHeaders()
    else:                                       # Standard conversion process
        returnCode = converter.convert(fileFormat=options.outputType)
    # Remove temp file, if any
    if options.inputList == '-':
        os.unlink(inputFile)
    #
    sys.exit(returnCode)
